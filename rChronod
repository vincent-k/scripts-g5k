#!/usr/bin/env python -u
from sys import *
from os.path import *
import BaseHTTPServer
import re
import time

from urlparse import urlparse
starts = {}
stops = {}
verbose = False

# Default port
port = 85439

class MyHandler(BaseHTTPServer.BaseHTTPRequestHandler):

    def log_message( self, format, *args ):
        pass

    def toJSON(self, t):
        j = "{'id': '" + t + "'"
        if t in starts:
            j += ", 'start': "
            j += str(starts[t])
        if t in stops:
            j += ", 'stop': " 
            j += str(stops[t])
            j += ", 'duration': "
            j += str(stops[t] - starts[t])
        j += "}"
        return j 

    def do_GET(self): 
        url = urlparse(self.path)        
        if len(url.path) == 1: #list
            buf = "["
            buf += ', '.join("%s" % self.toJSON(t) for t in starts.keys())
            buf += "]"            
            self.reply(200, "text/json", buf)            
        else: # A given token
            token = urlparse(self.path).path[1:]                       
            if token not in starts:
                self.reply(404,"text/plain","Counter '" + token + "' does not exist")
            else:
                self.reply(200,"text/json",self.toJSON(token))                
    def do_POST(self):                
        token = urlparse(self.path).path[1:]        
        global starts
        global verbose
        if (len(token) == 0):
            self.reply(400,"text/plain","Missing counter name")
        elif token in starts: #Already started
            self.reply(409,"text/plain","Counter '" + token + "' already exists")
        else:
            starts[token] = int(round(time.time() * 1000)) #Start the counter            
            self.send_response(201)
            self.send_header("Location", "/" + token)
            self.end_headers()                                        
            if (verbose):
                print("Counter '" + token + "' started")	
    
    def reply(self, st, mime, cnt):
        self.send_response(st)
        self.send_header("Content-type", mime)
        self.end_headers()        
        if verbose:
            print(r)
            stdout.flush()
        self.wfile.write(cnt)

    def do_PUT(self):
        token = urlparse(self.path).path[1:]        
        if not token in starts:
            self.reply(404, "text/plain","Counter '" + token + "' does not exists")            
        elif token in stops: #Already stopped
            self.reply(409, "text/plain","Counter '" + token + "' already stopped")            
        else:
            stops[token] = int(round(time.time() * 1000)) #Stop the counter                            
            self.reply(200, "text/json",self.toJSON(token))            

    def do_DELETE(self):
        token = urlparse(self.path).path[1:]
        if not token in starts:
            self.reply(404,"text/plain", "Counter '" + token + "' does not exist")              
        else:    
            del starts[token]
            del stops[token]
            self.reply(200,"text/plain","")

if len(argv) < 2 or argv[1] in ["-h", "--help"]:
    print("rChronoTrigger url")
    exit(1)

if re.search(":", argv[1]) != None:
    host,port = argv[1].split(":")
    port = int(port)
else:
    host = argv[1]

server_class = BaseHTTPServer.HTTPServer
httpd = server_class((host, port), MyHandler)
print("Waiting on " + host + ":" + str(port))
stdout.flush()
try:
    httpd.serve_forever()
except KeyboardInterrupt:
    pass
httpd.server_close()
