#!/usr/bin/env python -u
from sys import *
from os.path import *
import BaseHTTPServer
import re
import time

from urlparse import urlparse
starts = {}
stops = {}
verbose = False

# Default port
port = 85439


class MyHandler(BaseHTTPServer.BaseHTTPRequestHandler):

    def log_message( self, format, *args ):
        pass

    def toJSON(self, t):
        j = "{'id': " + t
        if t in starts:
            j += ", 'start': "
            j += str(starts[t])
        if t in stops:
            j += ", 'stop': " 
            j += str(stops[t])
            j += ", 'duration': "
            j += str(stops[t] - starts[t])
        j += "}"
        return j 

    def do_GET(self): 
        url = urlparse(self.path)        
        if len(url.path) == 1: #list
            self.send_response(200)
            self.send_header("Content-type", "text/json")
            self.end_headers()
            self.wfile.write("[")
            self.wfile.write(', '.join("%s" % self.toJSON(t) for t in starts.keys()))
            self.wfile.write("]")
        else: # A given token
            token = urlparse(self.path).path[1:]                       
            if token not in starts:
                self.send_response(404)
                self.end_headers()                            
                self.reply("Counter '" + token + "' does not exist")
            else:
                self.send_response(200)
                self.send_header("Content-type", "text/json")
                self.end_headers()
                self.wfile.write(self.toJSON(token))        
            

    def do_POST(self):                
        token = urlparse(self.path).path[1:]        
        global starts
        global verbose
        if (len(token) == 0):
            self.send_response(400)
            self.end_headers()
        elif token in starts: #Already started
            self.send_response(409)
            self.end_headers()
            self.reply("Counter '" + token + "' already exists")
        else:
            starts[token] = int(round(time.time() * 1000)) #Start the counter
            self.send_response(201)
            self.send_header("Location", "/" + token)
            self.end_headers()                                
            if (verbose):
                print("Counter '" + token + "' started")
		stdout.flush()
    
    def reply(self, r):
        if verbose:
            print(r)
        self.wfile.write(r)

    def do_PUT(self):
        token = urlparse(self.path).path[1:]        
        if not token in starts:
            self.send_response(404)
            self.end_headers()
            self.reply("Counter '" + token + "' does not exists")
        elif token in stops: #Already stopped
            self.send_response(409)
            self.end_headers()
            self.reply("Counter '" + token + "' already stopped")            
        else:
            stops[token] = int(round(time.time() * 1000)) #Stop the counter                            
            self.send_response(200)
            self.send_header("Content-type", "text/json")
            self.end_headers()
            self.reply(self.toJSON(token))              
        stdout.flush()

    def do_DELETE(self):
        token = urlparse(self.path).path[1:]
        if not token in starts:
            self.send_response(404)
            self.end_headers()
            self.reply("Counter '" + token + "' does not exist")              
        del starts[token]
        del stops[token]
        self.send_response(200)
        self.end_headers()
        stdout.flush()

if len(argv) < 2 or argv[1] in ["-h", "--help"]:
    print("rChronoTrigger url")
    exit(1)

if re.search(":", argv[1]) != None:
    host,port = argv[1].split(":")
    port = int(port)
else:
    host = argv[1]

server_class = BaseHTTPServer.HTTPServer
httpd = server_class((host, port), MyHandler)
print("Waiting on " + host + ":" + str(port))
stdout.flush()
try:
    httpd.serve_forever()
except KeyboardInterrupt:
    pass
httpd.server_close()
